{
  "config": "baseline",
  "repo_dir": "/tmp/swebench_iu299bow/pylint-dev__pylint",
  "wall_time_seconds": 471,
  "git_diff": "diff --git a/pylint/lint/expand_modules.py b/pylint/lint/expand_modules.py\nindex 289e1afce..3217c86cc 100644\n--- a/pylint/lint/expand_modules.py\n+++ b/pylint/lint/expand_modules.py\n@@ -30,8 +30,7 @@ def get_python_path(filepath: str) -> str:\n     This is not true since python 3.3 and is causing problem.\n     \"\"\"\n     dirname = os.path.realpath(os.path.expanduser(filepath))\n-    if not os.path.isdir(dirname):\n-        dirname = os.path.dirname(dirname)\n+    dirname = os.path.dirname(dirname)\n     while True:\n         if not os.path.exists(os.path.join(dirname, \"__init__.py\")):\n             return dirname\ndiff --git a/tests/lint/unittest_expand_modules.py b/tests/lint/unittest_expand_modules.py\nindex 15f72d0c5..940eaae0d 100644\n--- a/tests/lint/unittest_expand_modules.py\n+++ b/tests/lint/unittest_expand_modules.py\n@@ -10,11 +10,43 @@ from pathlib import Path\n import pytest\n \n from pylint.checkers import BaseChecker\n-from pylint.lint.expand_modules import _is_in_ignore_list_re, expand_modules\n+from pylint.lint.expand_modules import _is_in_ignore_list_re, expand_modules, get_python_path\n from pylint.testutils import CheckerTestCase, set_config\n from pylint.typing import MessageDefinitionTuple\n \n \n+def test_expand_modules_with_no_duplicates_from_same_name(tmp_path: Path) -> None:\n+    \"\"\"Regression test for https://github.com/PyCQA/pylint/issues/5621\n+\n+    When a directory 'a' contains a file 'a.py' (same name as the directory),\n+    expand_modules should not fail with a parse error for the non-existent 'a/__init__.py'.\n+    \"\"\"\n+    # Create directory 'a' with 'a.py' and 'b.py' but no '__init__.py'\n+    a_dir = tmp_path / \"a\"\n+    a_dir.mkdir()\n+    (a_dir / \"a.py\").write_text(\"\")\n+    (a_dir / \"b.py\").write_text(\"\")\n+\n+    modules, errors = expand_modules(\n+        [str(a_dir)],\n+        ignore_list=[],\n+        ignore_list_re=[],\n+        ignore_list_paths_re=[],\n+    )\n+\n+    # There should be no errors (the bug caused \"Unable to load file a/__init__.py\")\n+    assert not errors\n+\n+\n+def test_get_python_path_for_directory(tmp_path: Path) -> None:\n+    \"\"\"get_python_path should return the parent of a directory, not the directory itself.\"\"\"\n+    a_dir = tmp_path / \"a\"\n+    a_dir.mkdir()\n+\n+    result = get_python_path(str(a_dir))\n+    assert result == str(tmp_path)\n+\n+\n def test__is_in_ignore_list_re_match() -> None:\n     patterns = [\n         re.compile(\".*enchilada.*\"),\n",
  "claude_output": {
    "type": "result",
    "subtype": "success",
    "is_error": false,
    "duration_ms": 469970,
    "duration_api_ms": 473692,
    "num_turns": 37,
    "result": "Here's a summary of the fix:\n\n## Root Cause\n\nIn `get_python_path()` in `pylint/lint/expand_modules.py`, when given a **directory** path (like `a/`), the function returned the directory itself (`/project/a`) instead of its parent (`/project`). This was caused by this logic:\n\n```python\ndirname = os.path.realpath(os.path.expanduser(filepath))\nif not os.path.isdir(dirname):   # False for directories \u2192 skip os.path.dirname!\n    dirname = os.path.dirname(dirname)\n```\n\n## Impact of the bug\n\nWhen `pylint a` is run with a namespace package directory `a/` that contains `a/a.py`:\n1. `get_python_path(\"a\")` returns `/project/a` (wrong \u2014 should be `/project`)\n2. `/project/a` ends up in the search path for `file_info_from_modpath([\"a\"], ...)`\n3. This finds `/project/a/a.py` (the `a.py` with the same name as the directory!)\n4. `is_namespace` becomes `False` (it found a file, not a namespace package)\n5. The non-existent `a/__init__.py` gets added to the results\n6. Pylint fails trying to parse `a/__init__.py` with `F0010: Unable to load file`\n\n## Fix\n\nReplace the conditional `os.path.dirname()` call with an unconditional one:\n\n```python\ndirname = os.path.realpath(os.path.expanduser(filepath))\ndirname = os.path.dirname(dirname)  # Always get parent, same as for files\n```\n\nThis works because:\n- For **files** (`a/b.py`): `os.path.dirname(\"a/b.py\")` \u2192 `a/` (same as before)\n- For **directories** (`a/`): `os.path.dirname(\"a/\")` \u2192 parent dir (fixed!)\n- For **regular packages** (dir with `__init__.py`): the while loop still correctly walks up to find the Python path",
    "stop_reason": null,
    "session_id": "cd4450aa-c4a7-40a1-8f91-91391a32b0ef",
    "total_cost_usd": 1.8310609499999997,
    "usage": {
      "input_tokens": 39,
      "cache_creation_input_tokens": 37424,
      "cache_read_input_tokens": 1734772,
      "output_tokens": 20996,
      "server_tool_use": {
        "web_search_requests": 0,
        "web_fetch_requests": 0
      },
      "service_tier": "standard",
      "cache_creation": {
        "ephemeral_1h_input_tokens": 37424,
        "ephemeral_5m_input_tokens": 0
      },
      "inference_geo": "",
      "iterations": [],
      "speed": "standard"
    },
    "modelUsage": {
      "claude-sonnet-4-6": {
        "inputTokens": 39,
        "outputTokens": 20996,
        "cacheReadInputTokens": 1734772,
        "cacheCreationInputTokens": 37424,
        "webSearchRequests": 0,
        "costUSD": 1.6263809999999996,
        "contextWindow": 200000,
        "maxOutputTokens": 32000
      },
      "claude-haiku-4-5-20251001": {
        "inputTokens": 42504,
        "outputTokens": 6957,
        "cacheReadInputTokens": 878622,
        "cacheCreationInputTokens": 31623,
        "webSearchRequests": 0,
        "costUSD": 0.2046799499999999,
        "contextWindow": 200000,
        "maxOutputTokens": 32000
      }
    },
    "permission_denials": [],
    "uuid": "e449854b-d1e9-4c25-8256-2388d9fb8c32"
  },
  "session_id": "cd4450aa-c4a7-40a1-8f91-91391a32b0ef",
  "result_text": "Here's a summary of the fix:\n\n## Root Cause\n\nIn `get_python_path()` in `pylint/lint/expand_modules.py`, when given a **directory** path (like `a/`), the function returned the directory itself (`/project/a`) instead of its parent (`/project`). This was caused by this logic:\n\n```python\ndirname = os.path.realpath(os.path.expanduser(filepath))\nif not os.path.isdir(dirname):   # False for directories \u2192 skip os.path.dirname!\n    dirname = os.path.dirname(dirname)\n```\n\n## Impact of the bug\n\nWhen `pylint a` is run with a namespace package directory `a/` that contains `a/a.py`:\n1. `get_python_path(\"a\")` returns `/project/a` (wrong \u2014 should be `/project`)\n2. `/project/a` ends up in the search path for `file_info_from_modpath([\"a\"], ...)`\n3. This finds `/project/a/a.py` (the `a.py` with the same name as the directory!)\n4. `is_namespace` becomes `False` (it found a file, not a namespace package)\n5. The non-existent `a/__init__.py` gets added to the results\n6. Pylint fails trying to parse `a/__init__.py` with `F0010: Unable to load file`\n\n## Fix\n\nReplace the conditional `os.path.dirname()` call with an unconditional one:\n\n```python\ndirname = os.path.realpath(os.path.expanduser(filepath))\ndirname = os.path.dirname(dirname)  # Always get parent, same as for files\n```\n\nThis works because:\n- For **files** (`a/b.py`): `os.path.dirname(\"a/b.py\")` \u2192 `a/` (same as before)\n- For **directories** (`a/`): `os.path.dirname(\"a/\")` \u2192 parent dir (fixed!)\n- For **regular packages** (dir with `__init__.py`): the while loop still correctly walks up to find the Python path",
  "total_cost_usd": 1.8310609499999997,
  "num_turns": 37
}